#!/bin/bash

################################################################################
# pathhelper executable -- called from ~/.bash_profile
# author: Prem Muthedath
#
# pathhelper ensures that @ start of a bash session, PATH is always initialized 
# to the default system path -- the path that Apple sets. bash_profile then 
# PREPENDS user-defined custom paths to PATH.
#
# REF: see /u/ algal @ https://tinyurl.com/y574yqtw (so) on how Apple sets PATH
#
# why is pathhelper needed at all?
# 1. ensure correct PATH initialization -- no duplicates, right path order, etc.
# 2. when you manually source bash_profile, ensure PATH integrity -- that is, 
#    you don't end up with duplicate paths (bash does this!) & bad path order.
#
# DESIGN:
# 1. compute default system path -- named here as SYSPATH -- in right order -- 
#    in just the same way as Apple does:
#    (a) first, read /etc/paths file, & build ordered path sequence using paths 
#    listed there; ensure path sequence does not contain duplicates.
#    (b) next, read each file in etc/paths.d directory, in the order they are 
#    listed in the directory, & append path sequence (no dups) built from each 
#    file to result from (a).
#    (c) default system path = result from operations (a) & (b)
# 2. in doing (1), ensure that system path does not contain duplicates.
# 3. check if PATH == SYSPATH.  if yes, clean up, & exit.
# 4. else, log warning to ~/dotfiles/bash/log/path.log, return 
#    reset-PATH-to-SYSPATH command as string to bash_profile, clean up & exit.
# 5. trap any execution errors, clean up, and exit, returning "false" -- i.e., 
#    `false` command as string -- to caller in bash_profile.
################################################################################

function join () {
  # join path1 & path2, returning path1:path2
  # args: path1, path2

  # REF: for path1="${path1:+$path1:}$path2", see /u/ sancho.s @ 
  # https://tinyurl.com/y3ts4mle (so)
  local path1 path2 path
  path1="$1" path2="$2"
  path="${path1:+$path1:}$path2"
  echo "$path"
}

function fromfile () {
  # read file, and append all paths in it to fpath, ensuring no duplicates.
  # args: input file, fpath
  local file fpath
  file="$1" fpath="$2"

  # REF: for tilde expansion using parameter expansion, see 
  # https://tinyurl.com/y3muoeoj and https://tinyurl.com/y2mfzchz @ so
  # REF: `read -r` disables \ escape; treats each \ as part of input line; see
  # https://mywiki.wooledge.org/BashFAQ/001#trimming
  local path dup
  while IFS= read -r path
  do
    path="${path/#~/$HOME}" # replace '~' (if any) @ start with home directory
    dup="(^|:)$path(:|$)"   # `path` pattern for duplicate check
    # path MUST be a directory; if not (blanks, file, dummy, etc.), ignore it.
    # if fpath already contains path, do not include the path again.
    if [[ -d  "$path" ]] && [[ ! "$fpath" =~ $dup ]]; then
      fpath="$(join "$fpath" "$path")"
    fi
  done < "$file"
  echo "$fpath"
}

function system () {
  # compute & return default system path -- called here as FPATH -- in just the 
  # same way as Apple does @ start of a bash terminal session.
  # args: none.
  #
  # STEPS:
  # 1. read /etc/paths file, and compute path sequence, ignoring duplicates;
  # 2. next, read each file in /etc/paths.d directory, in listed order, & append 
  #    path sequence computed from each file to result in (a); ignore dups.
  # 3. return system path -- the result of operations (1) & (2)

  # NOTE: Apple uses an unordered file list from /etc/paths.d, the list you get 
  # with `ls -f` on paths.d directory, so we do the same here.
  local fnames filler FPATH
  fnames="$(/bin/ls -f "$pathsd")"    # file names from /etc/paths.d
  filler='â–¶'                          # filler for blank in file name
  FPATH="$(fromfile "$paths")"        # syspath built from /etc/paths

  # for each file in /etc/paths.d, append computed path sequence to FPATH
  local fname f
  for fname in ${fnames// /"$filler"}  # filler avoids file name split @ blanks.
  do
    f="$pathsd"/"${fname//"$filler"/ }"   # replace filler back with space
    if [[ -f "$f" ]]; then    # check if `f` is a file
      FPATH="$(fromfile "$f" "$FPATH")"
    fi
  done
  echo "$FPATH"
}

function log () {
  # log messages -- a string array -- to file, defined by $log.
  # args: messages -- an array
  #
  # BUG FIX: code below redirects ALL for-loop stdout, rather than just printf 
  # stdout, to file; this avoids mangled file content that results from 
  # interspersed writes from different bash terminal sessions to file.  this 
  # problem is particularly acute for large output -- i.e., when it takes longer 
  # time for each bash terminal session to write to file.
  # REF: https://mywiki.wooledge.org/BashGuide/InputAndOutput
  local messages item
  messages=("${@}")
  for item in "${messages[@]}"; do
    printf "\n%s" "$item"
  done 1> "$logfile"
}

function reset () {
  # log warnings & return reset-PATH-to-SYSPATH command as string.
  # args: none
  local syspath messages reset_path_cmd
  syspath="$SYSPATH"
  messages=("***** WARNING: PATH not equal to SYSPATH *****"
      "***** @ start of .bash_profile load, we want PATH=SYSPATH, the core path Apple sets  *****"
      ""
      "PATH:"
      "${PATH//:/$'\n'}"
      ""
      "SYSPATH:"
      "${syspath//:/$'\n'}"
      ""
      "***** Fix: reset PATH to SYSPATH  *****"
      "")
  log "${messages[@]}"
  reset_path_cmd="PATH=\"$SYSPATH\"; export PATH"
  echo "$reset_path_cmd"
}

function cleanup () {
  # capture execution status, clean up; if execution status is failure, return 
  # "false" -- i.e., `false` command as string -- to caller.
  # args: none

  # NOTE: capture the execution status first, BEFORE doing anything else!!
  local ARG=$?  # exit status of last executed command; non-zero => failure
  set +f        # clean up
  if (( "$ARG" != 0 )); then echo "false"; fi
}

function initialize () {
  # initialize PATH to default system path.
  # if PATH needs reset, return reset-PATH-to-SYSPATH command as string; 
  # otherwise, return nothing explicitly (of course, bash returns exit status).
  # args: none
  declare -r logfile="${HOME}/dotfiles/bash/log/path.log"   # log file
  declare -r paths='/etc/paths' pathsd='/etc/paths.d'       # file, dir for system paths

  # https://askubuntu.com/questions/831414/what-is-the-difference-between-touch-file-and-file
  : > "$logfile"    # create or overwrite log file; ':' is no-op command

  declare -r SYSPATH="$(system)"
  : ${SYSPATH:?can not be null/empty.  Aborting PATH initialization ...}
  if [[ "$PATH" != "$SYSPATH" ]]; then
    reset
  fi
}

# set -f => disable file name generation, aka globbing.
set -f; trap cleanup EXIT   # trap errors to ensure clean exit
initialize


