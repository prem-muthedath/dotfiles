#!/bin/bash -E

# NOTES:
# 1. with `-E` option, `ERR` trap is inherited by shell functions, command 
#    substitutions, & commands executed in a subshell.
# 2. this script SHOULD be executed in a subshell.
# REF: https://fvue.nl/wiki/Bash:_Error_handling
################################################################################
# pathhelper executable -- called from ~/.bash_profile
# author: Prem Muthedath
#
# pathhelper ensures that @ start of a bash session, as well as when you source 
# ~/.bash_profile, PATH is always initialized/reset to the default system path 
# that Apple sets.  bash_profile then PREPENDS user-defined custom paths to 
# PATH.  this ensures a valid PATH -- no duplicates & with paths in right order.
#
# REF: see /u/ algal @ https://tinyurl.com/y574yqtw (so) on how Apple sets PATH
#
# why is pathhelper needed at all?
# 1. ensure correct PATH initialization -- no duplicates, right path order, etc.
# 2. when you manually source bash_profile, ensure PATH integrity -- that is, 
#    you don't end up with duplicate paths (Apple does this!) & bad path order.
#
# DESIGN:
# 1. compute default system path -- named here as SYSPATH -- in right order -- 
#    in just the same way as Apple does:
#    (a) first, read /etc/paths file, & build ordered path sequence using paths 
#    listed there; ensure path sequence does not contain duplicates.
#    (b) next, read each file in etc/paths.d directory, in the order they are 
#    listed in the directory, & append path sequence (no dups) built from each 
#    file to result from (a).
#    (c) default system path = result from operations (a) & (b)
# 2. in doing (1), ensure that system path does not contain duplicates.
# 3. check if PATH == SYSPATH.  if yes, clean up, & exit with last exit status.
# 4. else, log warning to ~/dotfiles/bash/log/path.log, output 
#    reset-PATH-to-SYSPATH command as string to caller; finally, before exiting, 
#    capture exit status, clean up, & exit with captured exit status.
# 5. trap any error, clean up, & exit with captured exit status.
#
# USAGE:
# 1. always run this script in a subshell, so that `-E` setting works properly; 
#    this practice also avoids inadvertently altering bash terminal PATH.
# 2. default usage: "~/path/pathhelper" -- prints warnings, etc., to console.
# 3. silent mode: "~/path/pathhelper -s" -- shows only runtime errors, if any.
# 4. help mode: "~/path/pathhelper -h" -- displays usage info & exits.
# 5. PATH reset is logged (see `DESIGN`, item 4) both in default & silent modes.
################################################################################

function log() {
  # log messages -- a string array -- to file, defined by $log.
  # args: messages -- an array
  #
  # BUG FIX: code below redirects ALL for-loop stdout, rather than just printf 
  # stdout, to file; this avoids mangled file content that results from 
  # interspersed writes from different bash terminal sessions to file.  this 
  # problem is particularly acute for large output -- i.e., when it takes longer 
  # time for each bash terminal session to write to file.
  # REF: https://mywiki.wooledge.org/BashGuide/InputAndOutput
  local messages item
  messages=("${@}")
  for item in "${messages[@]}"; do
    printf "\n%s" "$item"
  done 1> "$logfile"
}

function log_path_reset() {
  # build path-reset message & log it.
  # args: none
  local syspath messages
  syspath="$SYSPATH"
  messages=("***** $(date) *****"
      "***** WARNING: PATH not equal to SYSPATH *****"
      "***** @ start of .bash_profile load, we want PATH=SYSPATH, the core path Apple sets  *****"
      ""
      "PATH:"
      "${PATH//:/$'\n'}"
      ""
      "SYSPATH:"
      "${syspath//:/$'\n'}"
      ""
      "***** Fix: reset PATH to SYSPATH  *****"
      "")
  log "${messages[@]}"
}

function reset() {
  # warn path reset & return reset-PATH-to-SYSPATH command as string.
  # args: none
  local reset_path_cmd
  log_path_reset
  reset_path_cmd="PATH=\"${SYSPATH}\"; export PATH"
  echo "$reset_path_cmd"
}

################################################################################

function printc() {
  # if not in silent mode, print to console (i.e., stderr), using colors.
  # arg: message
  #
  # NOTE: script's main output -- PATH -- goes to stdout, which is used by the 
  # calling program (i.e., bash_profile) to set PATH.  to avoid interfering with 
  # PATH output, we print these messages (warnings, etc.) to stderr.  that way,
  # user can see these console messages without screwing up PATH output.
  local msg;
  msg="$1"
  if [[ "$SILENT" = "false" ]]; then
    printf "${msg}\n" 1>&2
  fi
}

function shows() {
  # show status message on console.
  # args: status
  local status
  status="$1"
  printc "${CYAN}${status}${NC}"  # `NC` restricts color to just this output.
}

function warn() {
  # print warning to console.
  # args: warning
  # NOTE: `NC` restricts color to just this output.
  local warning
  warning="$1"
  printc "${ORANGE}warning => ${LGREEN}${warning}${NC}"
}

################################################################################

function fromfile() {
  # read file, and append all paths in it to fpath, ensuring no duplicates.
  # args: input file, fpath
  local file fpath
  file="$1" fpath="$2"

  # REF: for tilde expansion using parameter expansion, see 
  # https://tinyurl.com/y3muoeoj and https://tinyurl.com/y2mfzchz @ so
  # REF: `read -r` disables \ escape; treats each \ as part of input line; see
  # https://mywiki.wooledge.org/BashFAQ/001#trimming
  # REF: for fpath="${fpath:+${fpath}:}${path}", see /u/ sancho.s @ 
  # https://tinyurl.com/y3ts4mle (so)
  local path dup
  while IFS= read -r path
  do
    path="${path/#~/${HOME}}" # replace '~' (if any) @ start with home directory
    dup="(^|:)${path}(:|$)"   # `path` pattern for duplicate check
    # path MUST be a directory; if not (blanks, file, dummy, etc.), ignore it.
    # if fpath already contains path, do not include the path again.
    if [[ ! -d  "$path" ]]; then
      warn "path \"${path}\" in file \"${file}\" not a directory, so not added to PATH."
    elif [[ "$fpath" =~ $dup ]]; then
      warn "path \"${path}\" in file \"${file}\" already in PATH, so not added to PATH again."
    else
      fpath="${fpath:+${fpath}:}${path}"
    fi
  done < "$file" || exit $?
  echo "$fpath"
}

function system() {
  # compute & return default system path -- called here as FPATH -- in just the 
  # same way as Apple does @ start of a bash terminal session.
  # args: none.
  #
  # STEPS:
  # 1. read /etc/paths file, and compute path sequence, ignoring duplicates;
  # 2. next, read each file in /etc/paths.d directory, in listed order, & append 
  #    path sequence computed from each file to result in (a); ignore dups.
  # 3. return system path -- the result of operations (1) & (2)

  # NOTE: Apple uses an unordered file list from /etc/paths.d, the list you get 
  # with `ls -f` on paths.d directory, so we do the same here.
  local fnames filler FPATH

  fnames="$(/bin/ls -f "$pathsd")"    # file names from /etc/paths.d
  filler='â–¶'                          # filler for blank in file name
  FPATH="$(fromfile "$paths")"        # syspath built from /etc/paths
  : ${FPATH:?from \""${paths}"\" can not be empty/null. Aborting ...}

  # for each file in /etc/paths.d, append computed path sequence to FPATH
  local fname f
  for fname in ${fnames// /"$filler"}  # filler avoids file name split @ blanks.
  do
    f="$pathsd"/"${fname//"$filler"/ }"   # replace filler back with space
    if [[ -f "$f" ]]; then                # check if `f` is a file
      FPATH="$(fromfile "$f" "$FPATH")"
    else
      warn "\"${f}\" not a file, so ignored in PATH initialization."
    fi
  done
  echo "$FPATH"
}

################################################################################

function initialize() {
  # initialize PATH to default system path.
  # if PATH needs reset, output reset-PATH-to-SYSPATH command as string; 
  # otherwise, output `no-op` command as string.
  # args: none
  declare -r logfile="${HOME}/dotfiles/bash/log/path.log"   # log file
  declare -r paths="/etc/paths" pathsd="/etc/paths.d"       # file, dir for system paths

  shows "initializing PATH ..."     # print status
  # https://askubuntu.com/questions/831414/what-is-the-difference-between-touch-file-and-file
  : > "$logfile"  # create or overwrite log file; ':' is no-op command

  declare -r SYSPATH="$(system)"
  : ${SYSPATH:?can not be null/empty.  Aborting PATH initialization ...}
  if [[ "$PATH" != "$SYSPATH" ]]; then
    warn "RE-SETTING PATH -- see \"${logfile}\" for details."
    reset
  else
    echo ":"
  fi
  shows "done!"                     # print status
}

################################################################################

function help() {
  # print usage info to console.
  # args: none
  # help format: https://mywiki.wooledge.org/BashFAQ/035
  # printf usage with multiline string: https://tinyurl.com/yxzgx5a7
  # NOTE: `NC` restricts color to just this output.
  printf "${LGREEN}"'%s'"${NC}\n" \
    "Usage: ${0##*/} [-hs]" \
    "Customized PATH initialization." \
    "This script SHOULD be run in a subshell." \
    "   -h      display this help and exit." \
    "   -s      silent mode." 1>&2
}

function setopt() {
  # set option passed to script.
  # args: "$*"
  local opts
  opts="$1"  SILENT=false   # default mode is verbose
  case "$opts" in
    -h)   # help mode -- print usage info to console & exit
      help
      exit 1
      ;;
    -s)   # silent mode -- show nothing except runtime errors
      SILENT=true
      ;;
    '')   # default mode -- print (status, warnings) to console
      :
      ;;
    *)    # bad option -- warn, print usage info to console, & exit
      printf "${ORANGE}unknown option: '${opts}'${NC}\n" 1>&2
      help
      exit 1
      ;;
  esac
}

################################################################################

function printss() {
  # print script status (i.e., warnings, errors, etc.).
  # prints each line in file `"$statusfile"` to stderr.
  # args: none
  errorpattern="${0##*/}"   # which is nothing but this script's name.
  while IFS= read -r line; do
  if [[ "$line" =~ $errorpattern ]]; then
    line="${RED}ERROR => ${line}${NC}"    # color error line.
  fi
  printf "${line}\n"
  done < "$statusfile" 1>&2    # print to stderr
}

function cleanup() {
  # capture exit status, clean up, & exit with captured exit status.
  # args: none

  # NOTE: capture the exit status first, BEFORE doing anything else!!
  local ARG=$?  # exit status of last executed command; non-zero => failure
  if [[ -f "$statusfile" ]]; then
    # print script status (warnings, errors, etc.) & then delete status file.
    { printss &&
      rm -f "$statusfile"
    } ||
    # capture (failed) status code & print error message to stderr.
    { ARG=$?
      printf "${RED}ERROR => failed to remove ${statusfile}.${NC}\n" 1>&2
    }
  fi
  set +f    # clean up
  exit "${ARG}"
}

################################################################################

# REF: `man bash` -- traps: ERR with -E => simple command non-zero status exit 
# from functions, $(), & subshells; EXIT => exit from this shell only.
# REF: options parsing, see https://wiki.bash-hackers.org/scripting/posparams
#
# NOTES:
# 1. we create a file with randomized name to capture, during execution, all 
#    status, warnings, errors. by having a randomized file name, we ensure each 
#    bash terminal session has a unique file, avoiding file-resource clashes 
#    between sessions.  `cleanup()` removes this file before exit.
# 2. stderr in a variable: see /u/ tripleee @ https://tinyurl.com/y5tyf4hh (so)
set -f  # disable file name generation (globbing); inherited by subshells.
declare -r statusfile="${HOME}/dotfiles/bash/log/status${RANDOM}.txt"
trap 'exit $?' ERR  # trap error & exit
trap cleanup EXIT   # ensure clean exit
setopt "$*"         # "$*" expands to "$1c$2c$3...$N"; 'c' is `IFS` 1st char.
var="$(initialize 2>"$statusfile")"   # NOTE: if you run `set -x`, it's output will also go to file.
echo "$var"
exit 0

################################################################################


