#!/bin/bash -

function fromfile () {
	declare -r file="$1"
	local fpath="$2"
	while IFS= read -r path   # -r disables escaping \; treats each \ as part of input line
	do
		pattern="(^|:)$path(:|$)"
		if [[ ! "$fpath" =~ $pattern ]]; then
			fpath=$(join "$fpath" "$path")
		fi
	done < "$file"
	echo "$fpath"
}

function join () {
	declare -r path1="$1" path2="$2"
	declare -r path="${path1:+$path1:}$path2"
	echo "${path%:}"
}

function system () {
	declare -r etcpaths="/etc/paths" etcpathsd="/etc/paths.d"
	declare -r paths="${1:-$etcpaths}" pathsd="${2:-$etcpathsd}"

	local FPATH=$(fromfile "$paths")
	for f in $(/bin/ls -f "$pathsd")
	do
		f="$pathsd"/"$f"
		if [[ -f "$f" ]]; then
			FPATH=$(fromfile "$f" "$FPATH")
		fi
	done
	echo "$FPATH"
}

function log () {
	declare -r messages=("${@}")
	for item in "${messages[@]}"; do
		printf "\n%s" "${item}" >> "$log"
	done
}

function reset () {
	declare -r syspath="$(evalsys)"
	declare -r messages=("***** WARNING: PATH not equal to SYSPATH *****"
		"***** @ start of .bash_profile load, we want PATH=SYSPATH, the core path Apple sets  *****" 
		""
		"PATH:"
		"${PATH//:/$'\n'}"
		""
		"SYSPATH:"
		"${syspath//:/$'\n'}"
		""
		"***** Fix: reset PATH to SYSPATH  *****"
		"")
	log "${messages[@]}"
	echo "PATH=\"$SYSPATH\"; export PATH"
}

function evalsys () {
	eval echo $(echo \""$SYSPATH"\")
}

function initialize () {
	declare -r log=~/dotfiles/log/path.log 
	: > "$log"

	declare -r SYSPATH=$(system)
 	: ${SYSPATH:?can not be null/empty. Missing system (i.e., OS) paths -- such as /usr/bin, /bin -- reqd for a Bash session. Aborting PATH initialization ...}	
	if [[ "$PATH" != "$(evalsys)" ]]; then
		reset
	fi
}

initialize



